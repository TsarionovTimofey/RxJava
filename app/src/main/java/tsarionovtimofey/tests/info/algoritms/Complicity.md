### Сложность алгоритмов: Временная и пространственная сложность

Сложность алгоритмов оценивается через **временную** и **пространственную сложность**, которые
показывают, как растет потребление ресурсов (время или память) с увеличением размера входных данных
**n**. Основной инструмент для анализа — **O-нотация** (асимптотическая сложность).

---

### **1. Временная сложность (Time Complexity)**

Оценивает, как быстро алгоритм обрабатывает данные. Основные классы:

#### **a) Константное время O(1)**

- **Описание**: Время выполнения не зависит от размера данных.
- **Пример**:
    - Доступ к элементу массива по индексу: `array[5]`.
    - Проверка условия: `if (n % 2 == 0)`.

#### **b) Линейное время O(n)**

- **Описание**: Время растет пропорционально n.
- **Пример**:
    - Линейный поиск элемента в списке:
      ```kotlin
      fun findElement(list: List<Int>, target: Int): Boolean {
          for (element in list) {
              if (element == target) return true
          }
          return false
      }
      ```
      **Худший случай**: `n` итераций.

#### **c) Логарифмическое время O(log n)**

- **Описание**: Сложность растет медленно с ростом n (например, бинарный поиск).
- **Пример**:
    - Бинарный поиск в отсортированном массиве:
      ```kotlin
      fun binarySearch(arr: IntArray, target: Int): Int {
          var left = 0
          var right = arr.size - 1
          while (left <= right) {
              val mid = (left + right) / 2
              if (arr[mid] == target) return mid
              if (arr[mid] < target) left = mid + 1
              else right = mid - 1
          }
          return -1
      }
      ```
      Каждая итерация уменьшает область поиска в **2 раза**.

#### **d) Линейно-логарифмическое время O(n log n)**

- **Описание**: Сложность пропорциональна n умноженному на log n.
- **Примеры**:
    - Быстрая сортировка:
      ```kotlin
      fun quickSort(arr: IntArray): IntArray {
          if (arr.size <= 1) return arr
          val pivot = arr[arr.size / 2]
          val less = arr.filter { it < pivot }.toIntArray()
          val equal = arr.filter { it == pivot }.toIntArray()
          val greater = arr.filter { it > pivot }.toIntArray()
          return quickSort(less) + equal + quickSort(greater)
      }
      ```
    - Сортировка слиянием.

#### **e) Квадратичное время O(n²)**

- **Описание**: Время растет пропорционально квадрату n.
- **Пример**:
    - Пузырьковая сортировка:
      ```kotlin
      fun bubbleSort(arr: IntArray) {
          val n = arr.size
          for (i in 0 until n) {
              for (j in 0 until n - i - 1) {
                  if (arr[j] > arr[j + 1]) {
                      arr[j] += arr[j + 1].also { arr[j + 1] = arr[j] - it }
                  }
              }
          }
      }
      ```
      **Худший случай**: `n²` операций.

#### **f) Экспоненциальное время O(2ⁿ)**

- **Описание**: Сложность растет как 2ⁿ (например, рекурсивные алгоритмы без оптимизации).
- **Пример**:
    - Рекурсивный расчет чисел Фибоначчи без мемоизации:
      ```kotlin
      fun fib(n: Int): Int {
          return if (n <= 1) n else fib(n - 1) + fib(n - 2)
      }
      ```
      Количество вызовов = `2ⁿ`.

---

### **2. Пространственная сложность (Space Complexity)**

Оценивает использование памяти. Примеры:

- **O(1)**: Не использует дополнительную память, например, поиск элемента в массиве.
- **O(n)**: Хранит копию данных (например, алгоритм сортировки, создающий временный массив).
- **O(n²)**: Двумерные массивы (например, матрицы).

---

### **3. Сравнение классов сложности**

| Класс          | Пример n=1000 | Пример n=10⁶ | Применимость                  |
|----------------|---------------|--------------|-------------------------------|
| **O(1)**       | 1 операция    | 1 операция   | Оптимально для любых задач    |
| **O(log n)**   | ~10 операций  | ~20 операций | Эффективно даже для больших n |
| **O(n)**       | 1000 операций | 10⁶ операций | Принято, если n < 10⁶         |
| **O(n log n)** | ~10⁴ операций | ~2·10⁷       | Хорошо для сортировок         |
| **O(n²)**      | 10⁶ операций  | 10¹²         | Неприемлемо для n > 10⁴       |
| **O(2ⁿ)**      | 2¹⁰⁰⁰ (~∞)    | ~∞           | Только для маленьких n        |

---

### **4. Практические примеры сравнения**

#### **Пример 1: Поиск элемента**

- **Линейный поиск (O(n))**: Ищет элемент в неупорядоченном списке.
- **Бинарный поиск (O(log n))**: Требует отсортированного массива, но работает быстрее для больших
  n.

#### **Пример 2: Сортировка**

- **Пузырьковая сортировка (O(n²))**: Неприемлема для n=10⁵ (10¹⁰ операций).
- **Быстрая сортировка (O(n log n))**: Обрабатывает n=10⁶ за ~60 млн операций.

#### **Пример 3: Рекурсивные алгоритмы**

- **Фибоначчи без мемоизации (O(2ⁿ))**: Для n=30 уже ~1 млрд операций.
- **Мемоизация (O(n))**: Хранит результаты, сокращая время до линейного.

---

### **5. Зачем это важно?**

- **Производительность**: Алгоритм O(n²) может стать неприемлемым даже для n=10⁴.
- **Скалируемость**: Для больших данных выбирают алгоритмы с O(n log n) или O(n).
- **Оптимизация**: Например, замена вложенных циклов (O(n²)) на хэш-таблицу (O(n)).

---

### **6. Советы для анализа**

1. **Игнорируйте константы**: `O(2n)` ≈ `O(n)`, так как асимптотика зависит от n.
2. **Берите доминирующую часть**: `O(n² + log n)` ≈ `O(n²)`.
3. **Учитывайте лучший/средний/худший случаи**: Бинарный поиск всегда O(log n), а пузырьковая
   сортировка в лучшем случае (уже отсортированный массив) — O(n).

---

### **7. Примеры сложности в коде**

#### **Пример 1: O(1)**

```kotlin
fun getFirstElement(list: List<Int>): Int? = list.firstOrNull() // Операция за константное время
```

#### **Пример 2: O(n)**

```kotlin
fun sumNumbers(numbers: List<Int>): Int {
    var total = 0
    for (num in numbers) total += num // n итераций
    return total
}
```

#### **Пример 3: O(n²)**

```kotlin
fun printAllPairs(n: Int) {
    for (i in 0 until n) {
        for (j in 0 until n) {
            println("Pair ($i, $j)") // n * n = n² операций
        }
    }
}
```

---

### **Итог**

Выбор алгоритма зависит от:

- Размера данных (n).
- Допустимого времени выполнения.
- Допустимого использования памяти.

**Идеальный баланс**: Низкая временная сложность + разумная пространственная сложность.

Вот примеры временной сложности для операций с коллекциями в Kotlin, включая списки (`List`/
`ArrayList`), множества (`Set`/`HashSet`/`LinkedHashSet`), карты (`Map`/`HashMap`), а также
функции-расширения. Все примеры основаны на стандартных реализациях в Kotlin (например, `List` по
умолчанию использует `ArrayList`).

---

### **1. Операции с List (например, ArrayList)**

| **Операция**                  | **Временная Сложность** | **Пример кода**                                                |
|-------------------------------|-------------------------|----------------------------------------------------------------|
| **Доступ по индексу**         | **O(1)**                | `val element = list[index]`                                    |
| **Добавление в конец**        | **O(1)** (в среднем)    | `mutableList.add(element)`                                     |
| **Добавление в начало**       | **O(n)**                | `mutableList.add(0, element)` (требуется сдвиг всех элементов) |
| **Удаление по индексу**       | **O(n)**                | `mutableList.removeAt(index)` (сдвиг элементов)                |
| **Поиск элемента (contains)** | **O(n)**                | `if (element in list) { ... }` (перебор всех элементов)        |
| **Итерация (forEach)**        | **O(n)**                | `list.forEach { ... }`                                         |
| **Сортировка (sorted())**     | **O(n log n)**          | `sortedList = list.sorted()` (вызывает `Arrays.sort()`)        |

---

### **2. Операции с Set (например, HashSet)**

| **Операция**            | **Временная Сложность** | **Пример кода**               |
|-------------------------|-------------------------|-------------------------------|
| **Добавление элемента** | **O(1)** (в среднем)    | `mutableSet.add(element)`     |
| **Удаление элемента**   | **O(1)** (в среднем)    | `mutableSet.remove(element)`  |
| **Поиск (contains)**    | **O(1)** (в среднем)    | `if (element in set) { ... }` |
| **Итерация (forEach)**  | **O(n)**                | `set.forEach { ... }`         |

**Примечание для TreeSet**:

- Все операции (`add`, `remove`, `contains`) выполняются за **O(log n)**, так как TreeSet реализован
  через дерево.

---

### **3. Операции с Map (например, HashMap)**

| **Операция**                     | **Временная Сложность** | **Пример кода**                     |
|----------------------------------|-------------------------|-------------------------------------|
| **Добавление (put)**             | **O(1)** (в среднем)    | `map.put(key, value)`               |
| **Удаление (remove)**            | **O(1)** (в среднем)    | `map.remove(key)`                   |
| **Поиск по ключу (containsKey)** | **O(1)**                | `if (key in map) { ... }`           |
| **Итерация (forEach)**           | **O(n)**                | `map.forEach { key, value -> ... }` |

**Примечание для TreeMap**:

- Все операции (`get`, `put`, `remove`) выполняются за **O(log n)**, так как TreeMap реализован
  через красно-черное дерево.

---

### **4. Функции-расширения для коллекций**

| **Функция**      | **Временная Сложность** | **Пример кода**                                                  |
|------------------|-------------------------|------------------------------------------------------------------|
| **filter**       | **O(n)**                | `list.filter { it > 5 }` (перебор всех элементов)                |
| **map**          | **O(n)**                | `list.map { it * 2 }` (применение функции к каждому элементу)    |
| **reduce/sumOf** | **O(n)**                | `list.reduce { acc, i -> acc + i }` (итерация по всем элементам) |
| **find/first**   | **O(n)**                | `list.find { it == target }` (поиск до первого вхождения)        |
| **sortedBy**     | **O(n log n)**          | `list.sortedBy { it.length }` (сортировка)                       |

---

### **5. Примеры с конкретными типами коллекций**

#### **Пример 1: Добавление элемента в список**

```kotlin
// ArrayList (мутабельный список)
val mutableList = mutableListOf<Int>()
mutableList.add(5) // O(1) (в конец)
mutableList.add(0, 3) // O(n) (добавление в начало)
```

#### **Пример 2: Поиск в списке vs. HashSet**

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val set = hashSetOf(1, 2, 3, 4, 5)

// Поиск в списке: O(n)
val isPresentInList = 5 in list // Проверяет каждый элемент

// Поиск во множестве: O(1)
val isPresentInSet = 5 in set // Хэш-таблица
```

#### **Пример 3: Итерация и агрегация**

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

// Сумма через reduce: O(n)
val sum = numbers.reduce { acc, i -> acc + i } // 15

// Сумма через sumOf: O(n)
val sumOptimized = numbers.sumOf { it } // 15 (оптимизированная версия)
```

#### **Пример 4: Сортировка**

```kotlin
val unsorted = listOf(5, 3, 1, 4, 2)
val sortedList = unsorted.sorted() // O(n log n) — алгоритм быстрой сортировки
```

---

### **6. Сравнение сложности операций**

| **Операция**        | **ArrayList**  | **LinkedList** | **HashSet** | **TreeSet** | **HashMap** | **TreeMap** |
|---------------------|----------------|----------------|-------------|-------------|-------------|-------------|
| Добавление в конец  | O(1)           | O(1)           | N/A         | N/A         | N/A         | N/A         |
| Поиск элемента      | O(n)           | O(n)           | O(1)        | O(log n)    | O(1)        | O(log n)    |
| Добавление/удаление | O(n) (средний) | O(1)           | O(1)        | O(log n)    | O(1)        | O(log n)    |
| Итерация            | O(n)           | O(n)           | O(n)        | O(n)        | O(n)        | O(n)        |

---

### **7. Рекомендации по выбору коллекций**

- **Быстрый доступ/изменение в середине/начале**: Избегайте `ArrayList` (используйте `LinkedList`,
  но учтите O(n) для доступа).
- **Частые поиски**: Используйте `HashSet` или `HashMap` (O(1)).
- **Отсортированные данные**: `TreeSet` или `TreeMap` (O(log n) для операций).
- **Иммутабельные коллекции**: `listOf`, `setOf`, `mapOf` — операции вроде `plus` или `filter`
  создают копии (O(n)).

---

### **8. Опасные примеры с плохой сложностью**

#### **Пример 1: Вложенные циклы**

```kotlin
val list = (1..n).toList()
for (i in list) { // O(n)
    for (j in list) { // O(n) → общая O(n²)
        print("$i $j")
    }
}
```

---

### **Итог**

- **Ключевой принцип**: Избегайте O(n²) и выше для больших данных (n > 10⁴).
- **Используйте**: Хэш-таблицы для быстрого доступа, списки для последовательного доступа, деревья
  для отсортированных данных.
- **Анализируйте**: Всегда оценивайте сложность операций, особенно в циклах и рекурсии.