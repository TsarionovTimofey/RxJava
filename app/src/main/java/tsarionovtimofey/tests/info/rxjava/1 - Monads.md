### Сравнительная таблица:

| Тип Монады      | Количество эмитируемых значений | Бэкпрессинг | Основные методы                      | Пример использования                            |
|-----------------|---------------------------------|-------------|--------------------------------------|-------------------------------------------------|
| **Observable**  | 0 или больше                    | Нет         | `onNext`, `onComplete`, `onError`    | Поток событий, бесконечные потоки               |
| **Flowable**    | 0 или больше                    | Да          | `onNext`, `onComplete`, `onError`    | Большие или бесконечные потоки с бэкпрессингом  |
| **Single**      | Ровно одно                      | Нет         | `onSuccess`, `onError`               | Запрос к API, вычисление одного значения        |
| **Maybe**       | 0 или одно                      | Нет         | `onSuccess`, `onComplete`, `onError` | Поиск элемента, возможное отсутствие результата |
| **Completable** | Никаких значений                | Нет         | `onComplete`, `onError`              | Выполнение действия без результата              |

---

### Когда использовать каждый тип монады:

| Сценарий                                    | Рекомендуемый тип монады |
|---------------------------------------------|--------------------------|
| Поток событий или данных                    | **Observable**           |
| Большой поток данных с бэкпрессингом        | **Flowable**             |
| Операция с одним результатом                | **Single**               |
| Операция с возможным отсутствием результата | **Maybe**                |
| Выполнение действия без результата          | **Completable**          |

---

### Примечания:

1. **Бэкпрессинг:** `Flowable` является предпочтительным выбором для работы с большими или
   бесконечными потоками данных, так как он обеспечивает контроль над скоростью
   производства/потребления данных.
2. **Выбор монады:** Выбор между `Observable` и `Flowable` зависит от того, нужен ли механизм
   бэкпрессинга.
3. **Упрощение кода:** Использование `Single`, `Maybe` и `Completable` позволяет упростить код за
   счет ограничения количества возможных состояний.

---

### 1. **Observable**

- **Описание:** Основной тип монады в RxJava, который может эмитировать 0 или более элементов, а
  затем завершиться (`onComplete`) или вызвать ошибку (`onError`).
- **Использование:** Подходит для потоков данных неограниченного размера.
- **Основные методы:**
    - `onNext(T value)` — эмитирует значение.
    - `onComplete()` — обозначает успешное завершение потока.
    - `onError(Throwable error)` — обозначает ошибку.
- **Пример:**
  ```kotlin
  Observable.just("A", "B", "C")
      .map { it.uppercase() }
      .subscribe(
          { println("Received: $it") }, // onNext
          { println("Error: ${it.message}") }, // onError
          { println("Completed") } // onComplete
      )
  ```

---

### 2. **Flowable**

- **Описание:** Похож на `Observable`, но поддерживает управление бэкпрессингом (backpressure), что
  делает его более безопасным для работы с большими объемами данных.
- **Использование:** Используется для больших или бесконечных потоков данных, где важно
  контролировать скорость производства/потребления данных.
- **Основные методы:**
    - Аналогичны `Observable`, но требуют явного управления бэкпрессингом.
- **Пример:**
  ```kotlin
  Flowable.range(1, 1000)
      .onBackpressureBuffer() // Управление бэкпрессингом
      .map { it * 2 }
      .subscribe(
          { println("Received: $it") },
          { println("Error: ${it.message}") },
          { println("Completed") }
      )
  ```

---

### 3. **Single**

- **Описание:** Монада, которая эмитит ровно одно значение или вызывает ошибку. Это упрощенная
  версия `Observable`.
- **Использование:** Подходит для операций, которые должны вернуть один результат (например, запрос
  к API, вычисление значения).
- **Основные методы:**
    - `onSuccess(T value)` — эмитирует единственное значение.
    - `onError(Throwable error)` — обозначает ошибку.
- **Пример:**
  ```kotlin
  Single.just("Result")
      .map { "Processed $it" }
      .subscribe(
          { println("Success: $it") }, // onSuccess
          { println("Error: ${it.message}") } // onError
      )
  ```

---

### 4. **Maybe**

- **Описание:** Монада, которая может эмитить 0 или 1 значение, а затем завершиться или вызвать
  ошибку. Это гибрид между `Single` и `Observable`.
- **Использование:** Используется, когда результат может быть отсутствующим (например, поиск
  элемента по ID).
- **Основные методы:**
    - `onSuccess(T value)` — эмитирует единственное значение.
    - `onComplete()` — обозначает успешное завершение без значения.
    - `onError(Throwable error)` — обозначает ошибку.
- **Пример:**
  ```kotlin
  Maybe.just("Value")
      .filter { it.isNotEmpty() }
      .subscribe(
          { println("Found: $it") }, // onSuccess
          { println("Error: ${it.message}") }, // onError
          { println("Not found") } // onComplete
      )
  ```

---

### 5. **Completable**

- **Описание:** Монада, которая не эмитит никаких значений, а только завершается (`onComplete`) или
  вызывает ошибку (`onError`). Это аналог Promise в JavaScript.
- **Использование:** Используется для операций, которые выполняют действие без возвращаемого
  результата (например, сохранение данных).
- **Основные методы:**
    - `onComplete()` — обозначает успешное завершение.
    - `onError(Throwable error)` — обозначает ошибку.
- **Пример:**
  ```kotlin
  Completable.fromAction {
      println("Performing some action...")
  }.subscribe(
      { println("Action completed") }, // onComplete
      { println("Error: ${it.message}") } // onError
  )
  ```

---